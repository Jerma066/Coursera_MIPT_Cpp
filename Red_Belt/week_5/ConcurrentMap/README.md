## Задание по программированию: ConcurrentMap

В заготовке решения задачи «Шаблон Synchronized» мы уже слегка коснулись идеи о том, что уменьшение размера критической секции позволяет повысить скорость работы многопоточной программы. В этой задаче мы разовьём её больше.

Давайте представим, что у нас есть map, к которому обращаются несколько потоков. Чтобы синхронизировать доступ к нему, мы можем каждое обращение к этому map'у защитить мьютексом (например, завернув наш map в шаблон Synchronized). Теперь давайте представим, что у нас есть Synchronized<map<int, int>>, в котором хранятся все ключи от 1 до 10000. Интуитивно кажется, что когда из одного потока мы обращаемся к ключу 10, а из другого — например, к ключу 6712, то нет смысла защищать эти обращения одним и тем же мьютексом. Это отдельные области памяти, а внутреннюю структуру словаря мы никак не изменяем. При этом, если мы будем обращаться к ключу 6712 одновременно из нескольких потоков, то синхронизация, несомненно, понадобится.

Отсюда возникает идея — разбить наш словарь на нескольких подсловарей с непересекающимся набором ключей и защитить каждый из них отдельным мьютексом. Тогда при обращении разных потоков к разным ключам они нечасто будут попадать в один и тот же подсловарь, а значит, смогут параллельно его обрабатывать. Эту идею вам предстоит реализовать в этой задаче. Вам надо написать шаблон класса ConcurrentMap вот с таким интерфейсом:
```cpp
template <typename K, typename V>
class ConcurrentMap {
public:
  static_assert(is_integral_v<K>, "ConcurrentMap supports only integer keys");

  struct Access {
    V& ref_to_value;
  };

  explicit ConcurrentMap(size_t bucket_count);

  Access operator[](const K& key);

  map<K, V> BuildOrdinaryMap();
};
```

* static_assert в начале класса говорит, что в данной задаче предполагается, что ключами ConcurrentMap'а могут быть только целые числа.
* Конструктор класса ConcurrentMap<K, V> принимает количество подсловарей, на которые надо разбить всё пространство ключей.
* operator[] должен вести себя так же, как аналогичный оператор у map — если ключ key присутствует в словаре, он должен возвращать объект класса Access, содержащий ссылку на соответствующее ему значение; если же key отсутствует в словаре, в него надо добавить пару (key, V()) и вернуть объект класса Access, содержащий ссылку на только что добавленное значение.
* Структура Access, должна вести себя так же, как и в шаблоне Synchronized, — предоставлять ссылку на значение словаря и обеспечивать синхронизацию доступа к нему.
* Метод BuildOrdinaryMap должен сливать вместе части словаря и возвращать весь словарь целиком. При этом он должен быть потокобезопасным, то есть корректно работать, когда другие потоки выполняют операции с ConcurrentMap.
